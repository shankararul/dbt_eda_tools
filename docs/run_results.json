{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.7", "generated_at": "2024-10-06T10:06:19.436989Z", "invocation_id": "51033e2d-aac5-499c-adeb-e282efb12e15", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.173893Z", "completed_at": "2024-10-06T10:06:08.686109Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.689121Z", "completed_at": "2024-10-06T10:06:08.689121Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.5353267192840576, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.data_generator", "compiled": true, "compiled_code": "WITH date_gen AS (\n    \n\n\n\n\n\nwith rawdata as (\n\n    \n\n    \n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    \n    p0.generated_number * power(2, 0)\n     + \n    \n    p1.generated_number * power(2, 1)\n     + \n    \n    p2.generated_number * power(2, 2)\n     + \n    \n    p3.generated_number * power(2, 3)\n     + \n    \n    p4.generated_number * power(2, 4)\n     + \n    \n    p5.generated_number * power(2, 5)\n     + \n    \n    p6.generated_number * power(2, 6)\n     + \n    \n    p7.generated_number * power(2, 7)\n     + \n    \n    p8.generated_number * power(2, 8)\n     + \n    \n    p9.generated_number * power(2, 9)\n     + \n    \n    p10.generated_number * power(2, 10)\n     + \n    \n    p11.generated_number * power(2, 11)\n    \n    \n    + 1\n    as generated_number\n\n    from\n\n    \n    p as p0\n     cross join \n    \n    p as p1\n     cross join \n    \n    p as p2\n     cross join \n    \n    p as p3\n     cross join \n    \n    p as p4\n     cross join \n    \n    p as p5\n     cross join \n    \n    p as p6\n     cross join \n    \n    p as p7\n     cross join \n    \n    p as p8\n     cross join \n    \n    p as p9\n     cross join \n    \n    p as p10\n     cross join \n    \n    p as p11\n    \n    \n\n    )\n\n    select *\n    from unioned\n    where generated_number <= 2192\n    order by generated_number\n\n\n\n),\n\nall_periods as (\n\n    select (\n        \n\n    date_add(cast('2019-01-01' as date), interval (row_number() over (order by 1) - 1) day)\n\n\n    ) as date_day\n    from rawdata\n\n),\n\nfiltered as (\n\n    select *\n    from all_periods\n    where date_day <= cast('2025-01-01' as date)\n\n)\n\nselect * from filtered\n\n\n),\ncompany_gen AS (\n     SELECT 'MSFT' AS company_name\n     UNION ALL\n     SELECT 'GOG' AS company_name\n     UNION ALL\n     SELECT 'AMZN' AS company_name\n     UNION ALL\n     SELECT 'A' AS company_name\n     UNION ALL\n     SELECT 'FB' AS company_name\n),\ncountry_gen AS (\n    SELECT 'FR' AS country\n    UNION ALL\n    SELECT 'DE' AS country\n    UNION ALL\n    SELECT 'GB' AS country\n    UNION ALL\n    SELECT 'US' AS country\n    UNION all\n    SELECT 'CA' AS country\n)\n\nSELECT *, LENGTH(company_name)+LENGTH(country) AS str_length\nFROM date_gen, company_gen, country_gen", "relation_name": "\"dbt_db\".\"dbt_schema\".\"data_generator\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.714492Z", "completed_at": "2024-10-06T10:06:08.731575Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.737735Z", "completed_at": "2024-10-06T10:06:08.737735Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.02777242660522461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.data_aggregated", "compiled": true, "compiled_code": "SELECT\n    company_name\n    , country\n    , MIN(str_length) AS str_length\nFROM \"dbt_db\".\"dbt_schema\".\"data_generator\"\nWHERE\n    --exclude some rows. Keeps only 2 companies for France and 3 countries for MSFT\n    NOT (\n        (company_name = 'MSFT' AND country = 'DE')\n        OR\n        (country = 'FR' AND (company_name IN ('GOG','A','MSFT')))\n    )\nGROUP BY 1,2", "relation_name": "\"dbt_db\".\"dbt_schema\".\"data_aggregated\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.751038Z", "completed_at": "2024-10-06T10:06:08.782241Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.783805Z", "completed_at": "2024-10-06T10:06:08.783805Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.040297508239746094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.data_aggregated_mixed_granularity", "compiled": true, "compiled_code": "SELECT\n    company_name\n    , country\n    , CASE\n        WHEN date_day <= CAST('2022-01-01' AS DATE)  THEN CAST(date_trunc('year', date_day) AS Date)\n        WHEN date_day BETWEEN CAST('2022-01-01' AS DATE) AND CAST('2023-01-01' AS DATE) THEN CAST(date_trunc('month', date_day) AS DATE)\n        \n    END AS date_mixed_granularity\nFROM \"dbt_db\".\"dbt_schema\".\"data_generator\"\nWHERE company_name = 'FB' AND country = 'US'\nGROUP BY 1,2,3", "relation_name": "\"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.798388Z", "completed_at": "2024-10-06T10:06:08.818964Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.820964Z", "completed_at": "2024-10-06T10:06:08.820964Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.029632091522216797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.data_generator_enriched_describe", "compiled": true, "compiled_code": "\n\nSELECT\n    *\n    , IF(str_length<4,True,False)   AS is_short_string\nFROM \"dbt_db\".\"dbt_schema\".\"data_generator\"", "relation_name": "\"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.833552Z", "completed_at": "2024-10-06T10:06:08.844929Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.846946Z", "completed_at": "2024-10-06T10:06:08.846946Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.019932031631469727, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.missing_day", "compiled": true, "compiled_code": "\nWITH\nmissing_day AS (\n    SELECT *\n    FROM \"dbt_db\".\"dbt_schema\".\"data_generator\"\n    WHERE NOT (\n        \n        (company_name = 'FB' AND country = 'CA' AND date_day BETWEEN CAST('2019-05-01' AS DATE) AND CAST('2019-05-17' AS DATE)) OR\n        (company_name = 'GOOG' AND country = 'FR' AND date_day BETWEEN CAST('2020-01-01' AS DATE) AND CAST('2020-05-01' AS DATE)) OR\n        (company_name = 'AAPL' AND country = 'US' AND date_day BETWEEN CAST('2021-12-15' AS DATE) AND CAST('2021-12-26' AS DATE)) OR\n        \n        (date_day  BETWEEN CAST('2022-05-01' AS DATE) AND CAST('2022-05-05' AS DATE)) OR\n        \n        (country = 'DE' AND date_day BETWEEN CAST('2019-09-07' AS DATE) AND CAST('2019-09-09' AS DATE)) OR\n        \n        (company_name = 'AMZN' AND date_day BETWEEN CAST('2019-09-07' AS DATE) AND CAST('2019-09-09' AS DATE))\n    )\n)\nSELECT * FROM missing_day", "relation_name": "\"dbt_db\".\"dbt_schema\".\"missing_day\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.856625Z", "completed_at": "2024-10-06T10:06:08.863659Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.865668Z", "completed_at": "2024-10-06T10:06:08.865668Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01206517219543457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.missing_month", "compiled": true, "compiled_code": "\nWITH  raw_data AS (\n    SELECT\n        DISTINCT\n        company_name\n        , country\n        , CAST(date_trunc('month', date_day) AS Date) AS date_month\n    FROM \"dbt_db\".\"dbt_schema\".\"data_generator\"\n),\nmissing_month AS (\n    SELECT * FROM raw_data\n    WHERE NOT (\n        \n        (company_name = 'FB' AND country = 'CA' AND date_month BETWEEN CAST('2019-05-01' AS DATE) AND CAST('2019-07-05' AS DATE)) OR\n        (company_name = 'GOOG' AND country = 'FR' AND date_month BETWEEN CAST('2020-01-01' AS DATE) AND CAST('2020-05-01' AS DATE)) OR\n        (company_name = 'AAPL' AND country = 'US' AND date_month BETWEEN CAST('2021-05-15' AS DATE) AND CAST('2021-12-26' AS DATE)) OR\n        \n        (date_month  BETWEEN CAST('2022-05-01' AS DATE) AND CAST('2022-08-05' AS DATE)) OR\n        \n        (country = 'DE' AND date_month BETWEEN CAST('2019-09-07' AS DATE) AND CAST('2019-11-09' AS DATE)) OR\n        \n        (company_name = 'AMZN' AND date_month BETWEEN CAST('2019-01-07' AS DATE) AND CAST('2019-09-09' AS DATE))\n    )\n)\nSELECT * FROM missing_month", "relation_name": "\"dbt_db\".\"dbt_schema\".\"missing_month\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.874727Z", "completed_at": "2024-10-06T10:06:08.891361Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:08.894882Z", "completed_at": "2024-10-06T10:06:08.894882Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.025698423385620117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.missing_year", "compiled": true, "compiled_code": "\nWITH\nraw_data AS (\n    SELECT\n        DISTINCT\n        company_name\n        , country\n        , CAST(date_trunc('year', date_day) AS Date) AS date_year\n    FROM \"dbt_db\".\"dbt_schema\".\"data_generator\"\n)\n, missing_year AS (\n    SELECT * FROM raw_data\n    WHERE NOT (\n        \n        (company_name = 'FB' AND country = 'CA' AND date_year BETWEEN CAST('2019-05-01' AS DATE) AND CAST('2020-07-05' AS DATE)) OR\n        (company_name = 'GOOG' AND country = 'FR' AND date_year BETWEEN CAST('2020-01-01' AS DATE) AND CAST('2021-05-01' AS DATE)) OR\n        \n        (date_year  BETWEEN CAST('2021-05-01' AS DATE) AND CAST('2022-08-05' AS DATE)) OR\n        \n        (country = 'DE' AND date_year BETWEEN CAST('2019-09-07' AS DATE) AND CAST('2020-11-09' AS DATE)) OR\n        \n        (company_name = 'AMZN' AND date_year BETWEEN CAST('2020-01-07' AS DATE) AND CAST('2021-09-09' AS DATE)) OR\n        (date_year BETWEEN CAST('2021-05-07' AS DATE) AND CAST('2022-09-09' AS DATE))\n    )\n)\nSELECT * FROM missing_year", "relation_name": "\"dbt_db\".\"dbt_schema\".\"missing_year\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:08.901894Z", "completed_at": "2024-10-06T10:06:09.976202Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:09.979207Z", "completed_at": "2024-10-06T10:06:09.979207Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.0878825187683105, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.describe_ex2", "compiled": true, "compiled_code": "\n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_aggregated'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_date AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_boolean AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"describe_ex2\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:09.998824Z", "completed_at": "2024-10-06T10:06:10.040036Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:10.042037Z", "completed_at": "2024-10-06T10:06:10.042037Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.049256324768066406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.percent_of_total_ex1", "compiled": true, "compiled_code": "SELECT\n    country\n    , SUM(str_length) AS sum_2_str_length\n    -- example: sum\n    , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(sum(str_length)) OVER () !=0\n              , sum(str_length)\n              /\n              SUM(sum(str_length)) OVER ()\n              , NULL\n            )\n          \n        \n      , 3)\n\n AS sum_percent\n\n    , COUNT(company_name) AS count_company_name\n    -- example: count\n    -- defaults to count if no aggregation function is specified and 1 decimal if no precision is specified\n\n    , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(COUNT(company_name)) OVER () !=0\n              , COUNT(company_name)\n              /\n              SUM(COUNT(company_name)) OVER ()\n              , NULL\n            )\n          \n        \n      , 3)\n\n AS count_percent\n\n    , COUNT(DISTINCT company_name) AS count_distinct_company_name\n    -- example: countdistinct\n    , \n\n  \n\n  \n\n      ROUND(\n        \n            \n              IF(SUM(COUNT(DISTINCT company_name)) OVER () !=0\n                , COUNT(DISTINCT company_name)\n                /\n                SUM(COUNT(DISTINCT company_name)) OVER ()\n                , NULL\n              )\n            \n        \n      , 3)\n\n AS count_distinct_percent\n\nFROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\nGROUP BY 1\nORDER BY sum(str_length)  DESC", "relation_name": "\"dbt_db\".\"dbt_schema\".\"percent_of_total_ex1\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:10.055645Z", "completed_at": "2024-10-06T10:06:10.065684Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:10.067686Z", "completed_at": "2024-10-06T10:06:10.067686Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.017567873001098633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.percent_of_total_ex2", "compiled": true, "compiled_code": "SELECT\n    company_name\n    , country\n    , count(str_length) AS count_str_length\n    -- the percentages are caclulated at the aggregation of company_name and not entire column\n    , \n\n  \n\n  \n    \n  \n\n      ROUND(\n        \n          \n            IF(SUM(count(str_length)) OVER (PARTITION BY company_name) !=0\n              , count(str_length)\n              /\n              SUM(count(str_length)) OVER (PARTITION BY company_name)\n              , NULL\n            )\n          \n        \n      , 3)\n\n AS count_percent_level_company_name\n    , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(COUNT(str_length)) OVER () !=0\n              , COUNT(str_length)\n              /\n              SUM(COUNT(str_length)) OVER ()\n              , NULL\n            )\n          \n        \n      , 2)\n\n AS count_percent_level_full_column\n\nFROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\nGROUP BY 1,2\nORDER BY company_name, country, count(str_length)  DESC", "relation_name": "\"dbt_db\".\"dbt_schema\".\"percent_of_total_ex2\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:10.075476Z", "completed_at": "2024-10-06T10:06:10.082506Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:10.084821Z", "completed_at": "2024-10-06T10:06:10.084821Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.012871026992797852, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_percent_of_total_level", "compiled": true, "compiled_code": "WITH\npercent_of_total AS (\n    SELECT\n        company_name\n        , country\n        , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(COUNT(str_length)) OVER () !=0\n              , COUNT(str_length)\n              /\n              SUM(COUNT(str_length)) OVER ()\n              , NULL\n            )\n          \n        \n      , 3)\n\n AS count_percent\n        , \n\n  \n\n  \n    \n  \n\n      ROUND(\n        \n          \n            IF(SUM(COUNT(str_length)) OVER (PARTITION BY company_name) !=0\n              , COUNT(str_length)\n              /\n              SUM(COUNT(str_length)) OVER (PARTITION BY company_name)\n              , NULL\n            )\n          \n        \n      , 3)\n\n AS count_percent_level\n\n    FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\n    GROUP BY 1,2\n    ORDER BY company_name, country, sum(str_length)  DESC\n)\nSELECT * FROM percent_of_total\nWHERE\n    1=1\n    -- aggregated percent at level is always greater than percent of entire column\n    AND\n    (\n        count_percent_level < count_percent\n    -- MSFT has 3 countries, so each should be 1/3 of the total\n    OR (company_name = 'MSFT' AND count_percent_level <> .333)\n    -- AMZN & FB are unfiltered and have 5 countries, so each should be 1/5 of the total\n    OR (company_name IN ('AMZN','FB') AND count_percent_level <> .2)\n    -- Each with 4 countries, so each should be 1/4 of the total\n    OR (company_name IN ('GOG','A') AND count_percent_level <> .25)\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:10.091372Z", "completed_at": "2024-10-06T10:06:10.098890Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:10.100400Z", "completed_at": "2024-10-06T10:06:10.100400Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.012547731399536133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_percent_of_total_rounding", "compiled": true, "compiled_code": "WITH\npercent_of_total AS (\n    SELECT\n    country\n    -- rounding defaults to 2 if unspecified\n    , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(sum(str_length)) OVER () !=0\n              , sum(str_length)\n              /\n              SUM(sum(str_length)) OVER ()\n              , NULL\n            )\n          \n        \n      , 2)\n\n AS sum_percent\n    , \n\n  \n\n  \n\n      ROUND(\n        \n          \n            IF(SUM(sum(str_length)) OVER () !=0\n              , sum(str_length)\n              /\n              SUM(sum(str_length)) OVER ()\n              , NULL\n            )\n          \n        \n      , 2)\n\n AS sum_percent_3\n\nFROM \"dbt_db\".\"dbt_schema\".\"data_aggregated\"\nGROUP BY 1\n)\nSELECT * FROM percent_of_total\nWHERE\n    country = 'GB'\n    AND sum_percent <> 0.2\n    AND sum_percent <> 0.24", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:10.105927Z", "completed_at": "2024-10-06T10:06:10.114838Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:10.116846Z", "completed_at": "2024-10-06T10:06:10.116846Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.013932943344116211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.data_aggregated_yearly_granularity", "compiled": true, "compiled_code": "SELECT\n    *\nFROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\nWHERE date_mixed_granularity <= CAST('2022-01-01' AS DATE)", "relation_name": "\"dbt_db\".\"dbt_schema\".\"data_aggregated_yearly_granularity\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:10.124919Z", "completed_at": "2024-10-06T10:06:11.304638Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:11.307665Z", "completed_at": "2024-10-06T10:06:11.307665Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.1978280544281006, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.describe_ex3", "compiled": true, "compiled_code": "\n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_aggregated_mixed_granularity'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_numeric AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_mixed_granularity AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_mixed_granularity) AS min\n                            , MAX(date_mixed_granularity) AS max\n                            \n                                , MIN('Monthly') AS estimated_granularity\n                                , MIN(0.8) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_mixed_granularity)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_mixed_granularity)) OVER () AS cnt_unique\n                    , COUNT_IF(date_mixed_granularity IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_mixed_granularity' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_mixed_granularity'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_mixed_granularity\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_boolean AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"describe_ex3\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:11.327233Z", "completed_at": "2024-10-06T10:06:12.339912Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:12.341914Z", "completed_at": "2024-10-06T10:06:12.341914Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.0283317565917969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_column_details_estimated_granularity", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_aggregated_mixed_granularity'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_numeric AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_mixed_granularity AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_mixed_granularity) AS min\n                            , MAX(date_mixed_granularity) AS max\n                            \n                                , MIN('Monthly') AS estimated_granularity\n                                , MIN(0.8) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_mixed_granularity)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_mixed_granularity)) OVER () AS cnt_unique\n                    , COUNT_IF(date_mixed_granularity IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_mixed_granularity\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_mixed_granularity' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_mixed_granularity'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_mixed_granularity\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_boolean AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    identifier = 'column'\n    AND\n    (\n        (\n            LOWER(meta_data_value) = 'date'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'DATE_MIXED_GRANULARITY' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'DATE_MIXED_GRANULARITY'\n                    OR CAST(detail->>'estimated_granularity' AS STRING) <> 'Monthly'\n                    OR CAST(detail->>'estimated_granularity_confidence' AS FLOAT) <> 0.8\n                    OR CAST(detail->>'count' AS INTEGER) <> 16\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 1\n                    OR CAST(detail->>'min' AS DATE) <> CAST('2019-01-01' AS DATE)\n                    OR CAST(detail->>'max' AS DATE) <> CAST('2023-01-01' AS DATE)\n                    )\n                )\n            )\n        )\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:12.358093Z", "completed_at": "2024-10-06T10:06:13.385979Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:13.388500Z", "completed_at": "2024-10-06T10:06:13.388500Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.046940565109253, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.describe_ex1", "compiled": true, "compiled_code": "\n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_generator_enriched_describe'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_day AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_day) AS min\n                            , MAX(date_day) AS max\n                            \n                                , MIN('Daily') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_day)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_day)) OVER () AS cnt_unique\n                    , COUNT_IF(date_day IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_day' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_day'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_day\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"describe_ex1\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:13.408577Z", "completed_at": "2024-10-06T10:06:14.418455Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:14.420465Z", "completed_at": "2024-10-06T10:06:14.420465Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.0279974937438965, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.describe_ex4", "compiled": true, "compiled_code": "\n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_day AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_day) AS min\n                            , MAX(date_day) AS max\n                            \n                                , MIN('Daily') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_day)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_day)) OVER () AS cnt_unique\n                    , COUNT_IF(date_day IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_day' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_day'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_day\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    , unioned_data AS (\n            \n                SELECT\n                   'numeric' AS dtype\n                    , * FROM\n                column_detail_info_numeric\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'text' AS dtype\n                    , * FROM\n                column_detail_info_text\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'date' AS dtype\n                    , * FROM\n                column_detail_info_date\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'boolean' AS dtype\n                    , * FROM\n                column_detail_info_boolean\n                WHERE column_name != ''\n                \n            \n        )\n        \n            , flatten_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    \n                        , json_extract(detail, '$.count') AS count\n                    \n                        , json_extract(detail, '$.count_null') AS count_null\n                    \n                        , json_extract(detail, '$.mean') AS mean\n                    \n                        , json_extract(detail, '$.percentile_25') AS percentile_25\n                    \n                        , json_extract(detail, '$.percentile_50') AS percentile_50\n                    \n                        , json_extract(detail, '$.percentile_75') AS percentile_75\n                    \n                        , json_extract(detail, '$.unique_values') AS unique_values\n                    \n                        , json_extract(detail, '$.value_counts_top10') AS value_counts_top10\n                    \n                        , json_extract(detail, '$.estimated_granularity') AS estimated_granularity\n                    \n                        , json_extract(detail, '$.estimated_granularity_confidence') AS estimated_granularity_confidence\n                    \n                        , json_extract(detail, '$.min') AS min\n                    \n                        , json_extract(detail, '$.max') AS max\n                    \n                    FROM unioned_data\n            )\n        \n        , unpivoted_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    , key AS pivot_key\n                    , JSON(value) AS pivot_value ,\n                FROM\n            \n                flatten_data AS f\n                UNPIVOT (\n                    value FOR key IN (count, count_null, mean, percentile_25, percentile_50, percentile_75, unique_values, value_counts_top10, estimated_granularity, estimated_granularity_confidence, min, max)\n                )\n            \n\n        )\n        SELECT\n            column_name\n            , dtype\n            , count\n            , count_null\n            , ROUND((\n                CAST(count_null AS NUMERIC)\n                / (CAST(count AS NUMERIC)+CAST(count_null AS NUMERIC))\n            ),3)\n\n            AS percent_null\n            , * EXCLUDE(column_name, dtype\n                , count\n                , count_null\n            )\n        FROM\n        unpivoted_data\n        PIVOT(MIN(pivot_value) FOR pivot_key IN (\"count\", \"count_null\", \"mean\", \"percentile_25\", \"percentile_50\", \"percentile_75\", \"unique_values\", \"value_counts_top10\", \"estimated_granularity\", \"estimated_granularity_confidence\", \"min\", \"max\"))\n        ORDER BY dtype\n\n\n    \n\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"describe_ex4\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:14.441977Z", "completed_at": "2024-10-06T10:06:14.926601Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:14.928603Z", "completed_at": "2024-10-06T10:06:14.928603Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.49968385696411133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.describe_ex5", "compiled": true, "compiled_code": "\n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    , unioned_data AS (\n            \n                SELECT\n                   'text' AS dtype\n                    , * FROM\n                column_detail_info_text\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'boolean' AS dtype\n                    , * FROM\n                column_detail_info_boolean\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'numeric' AS dtype\n                    , * FROM\n                column_detail_info_numeric\n                WHERE column_name != ''\n                \n            \n        )\n        \n            , flatten_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    \n                        , json_extract(detail, '$.count') AS count\n                    \n                        , json_extract(detail, '$.count_null') AS count_null\n                    \n                        , json_extract(detail, '$.mean') AS mean\n                    \n                        , json_extract(detail, '$.percentile_25') AS percentile_25\n                    \n                        , json_extract(detail, '$.percentile_50') AS percentile_50\n                    \n                        , json_extract(detail, '$.percentile_75') AS percentile_75\n                    \n                        , json_extract(detail, '$.unique_values') AS unique_values\n                    \n                        , json_extract(detail, '$.value_counts_top10') AS value_counts_top10\n                    \n                        , json_extract(detail, '$.estimated_granularity') AS estimated_granularity\n                    \n                        , json_extract(detail, '$.estimated_granularity_confidence') AS estimated_granularity_confidence\n                    \n                        , json_extract(detail, '$.min') AS min\n                    \n                        , json_extract(detail, '$.max') AS max\n                    \n                    FROM unioned_data\n            )\n        \n        , unpivoted_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    , key AS pivot_key\n                    , JSON(value) AS pivot_value ,\n                FROM\n            \n                flatten_data AS f\n                UNPIVOT (\n                    value FOR key IN (count, count_null, mean, percentile_25, percentile_50, percentile_75, unique_values, value_counts_top10, estimated_granularity, estimated_granularity_confidence, min, max)\n                )\n            \n\n        )\n        SELECT\n            column_name\n            , dtype\n            , count\n            , count_null\n            , ROUND((\n                CAST(count_null AS NUMERIC)\n                / (CAST(count AS NUMERIC)+CAST(count_null AS NUMERIC))\n            ),3)\n\n            AS percent_null\n            , * EXCLUDE(column_name, dtype\n                , count\n                , count_null\n            )\n        FROM\n        unpivoted_data\n        PIVOT(MIN(pivot_value) FOR pivot_key IN (\"count\", \"count_null\", \"mean\", \"percentile_25\", \"percentile_50\", \"percentile_75\", \"unique_values\", \"value_counts_top10\", \"estimated_granularity\", \"estimated_granularity_confidence\", \"min\", \"max\"))\n        ORDER BY dtype\n\n\n    \n\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"describe_ex5\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:14.945702Z", "completed_at": "2024-10-06T10:06:15.810550Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:15.814602Z", "completed_at": "2024-10-06T10:06:15.814602Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.8814582824707031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_all", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_day AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_day) AS min\n                            , MAX(date_day) AS max\n                            \n                                , MIN('Daily') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_day)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_day)) OVER () AS cnt_unique\n                    , COUNT_IF(date_day IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_day' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_day'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_day\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    , unioned_data AS (\n            \n                SELECT\n                   'numeric' AS dtype\n                    , * FROM\n                column_detail_info_numeric\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'text' AS dtype\n                    , * FROM\n                column_detail_info_text\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'date' AS dtype\n                    , * FROM\n                column_detail_info_date\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'boolean' AS dtype\n                    , * FROM\n                column_detail_info_boolean\n                WHERE column_name != ''\n                \n            \n        )\n        \n            , flatten_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    \n                        , json_extract(detail, '$.count') AS count\n                    \n                        , json_extract(detail, '$.count_null') AS count_null\n                    \n                        , json_extract(detail, '$.mean') AS mean\n                    \n                        , json_extract(detail, '$.percentile_25') AS percentile_25\n                    \n                        , json_extract(detail, '$.percentile_50') AS percentile_50\n                    \n                        , json_extract(detail, '$.percentile_75') AS percentile_75\n                    \n                        , json_extract(detail, '$.unique_values') AS unique_values\n                    \n                        , json_extract(detail, '$.value_counts_top10') AS value_counts_top10\n                    \n                        , json_extract(detail, '$.estimated_granularity') AS estimated_granularity\n                    \n                        , json_extract(detail, '$.estimated_granularity_confidence') AS estimated_granularity_confidence\n                    \n                        , json_extract(detail, '$.min') AS min\n                    \n                        , json_extract(detail, '$.max') AS max\n                    \n                    FROM unioned_data\n            )\n        \n        , unpivoted_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    , key AS pivot_key\n                    , JSON(value) AS pivot_value ,\n                FROM\n            \n                flatten_data AS f\n                UNPIVOT (\n                    value FOR key IN (count, count_null, mean, percentile_25, percentile_50, percentile_75, unique_values, value_counts_top10, estimated_granularity, estimated_granularity_confidence, min, max)\n                )\n            \n\n        )\n        SELECT\n            column_name\n            , dtype\n            , count\n            , count_null\n            , ROUND((\n                CAST(count_null AS NUMERIC)\n                / (CAST(count AS NUMERIC)+CAST(count_null AS NUMERIC))\n            ),3)\n\n            AS percent_null\n            , * EXCLUDE(column_name, dtype\n                , count\n                , count_null\n            )\n        FROM\n        unpivoted_data\n        PIVOT(MIN(pivot_value) FOR pivot_key IN (\"count\", \"count_null\", \"mean\", \"percentile_25\", \"percentile_50\", \"percentile_75\", \"unique_values\", \"value_counts_top10\", \"estimated_granularity\", \"estimated_granularity_confidence\", \"min\", \"max\"))\n        ORDER BY dtype\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    1=1\n    -- 5 column names as rows\n    AND\n    (\n        (\n        column_name NOT IN ('is_short_string', 'date_day', 'str_length', 'company_name', 'country')\n        )\n        OR column_name = 'is_short_string' AND NOT (\n            dtype = 'boolean' AND CAST(\"count\" AS INTEGER)=54800 AND CAST(\"unique_values\" AS INTEGER)=5\n            AND CAST(value_counts_top10->>'false' AS INTEGER) = 43840 AND CAST(value_counts_top10->>'true' AS INTEGER) = 10960\n        )\n        OR column_name = 'company_name' AND NOT (\n            dtype = 'text' AND CAST(\"count\" AS INTEGER)=54800 AND CAST(\"unique_values\" AS INTEGER)=5\n            AND CAST(value_counts_top10->>'AMZN' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'A' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'FB' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'MSFT' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'GOG' AS INTEGER) = 10960\n        )\n        OR column_name = 'country' AND NOT (\n            dtype = 'text' AND CAST(\"count\" AS INTEGER)=54800 AND CAST(\"unique_values\" AS INTEGER)=5\n            AND CAST(value_counts_top10->>'CA' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'GB' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'FR' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'DE' AS INTEGER) = 10960 AND CAST(value_counts_top10->>'US' AS INTEGER) = 10960\n\n        )\n        OR column_name = 'str_length' AND NOT (\n            dtype = 'numeric' AND CAST(\"count\" AS INTEGER)=54800 AND CAST(\"unique_values\" AS INTEGER)=5\n            AND \"max\" = 6 AND \"min\" = 3 AND \"mean\" = 4.8\n            AND \"percentile_25\" = 4 AND \"percentile_50\" = 5 AND \"percentile_75\" = 6\n        )\n        OR column_name = 'date_day' AND NOT (\n            dtype = 'date' AND CAST(\"count\" AS INTEGER)=54800 AND \"estimated_granularity\"='\"Daily\"' AND CAST(\"estimated_granularity_confidence\" AS INTEGER)= 1\n            AND \"max\" = '\"2024-12-31 00:00:00\"' AND \"min\" = '\"2019-01-01 00:00:00\"'\n        )\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:15.828635Z", "completed_at": "2024-10-06T10:06:16.664549Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:16.667559Z", "completed_at": "2024-10-06T10:06:16.667559Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.8534748554229736, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_column_details", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_generator_enriched_describe'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_day AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_day) AS min\n                            , MAX(date_day) AS max\n                            \n                                , MIN('Daily') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_day)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_day)) OVER () AS cnt_unique\n                    , COUNT_IF(date_day IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_day' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_day'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_day\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    identifier = 'column'\n    AND\n    (\n        (\n            LOWER(meta_data_value) = 'text'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'COMPANY_NAME' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'COMPANY_NAME'\n                    OR CAST(detail->>'count' AS INTEGER) <> 54800\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'unique_values' AS INTEGER) <> 5\n                    OR CAST(detail->>'value_counts_top10'->>'A' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'AMZN' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'FB' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'GOG' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'MSFT' AS INTEGER) <> 10960\n                    )\n                )\n\n                OR (\n                    meta_data_key = 'COUNTRY' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'COUNTRY'\n                    OR CAST(detail->>'count' AS INTEGER) <> 54800\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'unique_values' AS INTEGER) <> 5\n                    OR CAST(detail->>'value_counts_top10'->>'GB' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'US' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'FR' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'DE' AS INTEGER) <> 10960\n                    OR CAST(detail->>'value_counts_top10'->>'CA' AS INTEGER) <> 10960\n                    )\n                )\n            )\n        )\n        OR (\n            LOWER(meta_data_value) = 'number'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'STR_LENGTH' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'STR_LENGTH'\n                    OR CAST(detail->>'count' AS INTEGER) <> 54800\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'max' AS INTEGER) <> 6\n                    OR CAST(detail->>'min' AS INTEGER) <> 3\n                    OR ROUND(CAST(detail->>'mean' AS FLOAT),1) <> 4.8\n                    OR ROUND(CAST(detail->>'percentile_25' AS FLOAT),0) <> 4\n                    OR ROUND(CAST(detail->>'percentile_50' AS FLOAT),0) <> 5\n                    OR ROUND(CAST(detail->>'percentile_75' AS FLOAT),0) <> 6\n                    )\n                )\n            )\n        )\n        OR (\n            LOWER(meta_data_value) = 'date'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'DATE_DAY' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'DATE_DAY'\n                    OR CAST(detail->>'estimated_granularity' AS STRING) <> 'Daily'\n                    OR CAST(detail->>'estimated_granularity_confidence' AS INTEGER) <> 1\n                    OR CAST(detail->>'count' AS INTEGER) <> 54800\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'max' AS DATE) <> CAST('2019-01-01' AS DATE)\n                    OR CAST(detail->>'min' AS DATE) <> CAST('2024-12-31' AS DATE)\n                    )\n                )\n            )\n        )\n        OR (\n            LOWER(meta_data_value) = 'boolean'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'IS_SHORT_STRING' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'IS_SHORT_STRING'\n                    OR CAST(detail->>'count' AS INTEGER) <> 54800\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'value_counts_top10'->>'false' AS INTEGER) <> 43840\n                    OR CAST(detail->>'value_counts_top10'->>'true' AS INTEGER) <> 10960\n                    )\n                )\n            )\n        )\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:16.686349Z", "completed_at": "2024-10-06T10:06:17.347732Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:17.348733Z", "completed_at": "2024-10-06T10:06:17.348733Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.6798102855682373, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_include", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    , unioned_data AS (\n            \n                SELECT\n                   'text' AS dtype\n                    , * FROM\n                column_detail_info_text\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'boolean' AS dtype\n                    , * FROM\n                column_detail_info_boolean\n                WHERE column_name != ''\n                \n                    UNION ALL\n                \n            \n                SELECT\n                   'numeric' AS dtype\n                    , * FROM\n                column_detail_info_numeric\n                WHERE column_name != ''\n                \n            \n        )\n        \n            , flatten_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    \n                        , json_extract(detail, '$.count') AS count\n                    \n                        , json_extract(detail, '$.count_null') AS count_null\n                    \n                        , json_extract(detail, '$.mean') AS mean\n                    \n                        , json_extract(detail, '$.percentile_25') AS percentile_25\n                    \n                        , json_extract(detail, '$.percentile_50') AS percentile_50\n                    \n                        , json_extract(detail, '$.percentile_75') AS percentile_75\n                    \n                        , json_extract(detail, '$.unique_values') AS unique_values\n                    \n                        , json_extract(detail, '$.value_counts_top10') AS value_counts_top10\n                    \n                        , json_extract(detail, '$.estimated_granularity') AS estimated_granularity\n                    \n                        , json_extract(detail, '$.estimated_granularity_confidence') AS estimated_granularity_confidence\n                    \n                        , json_extract(detail, '$.min') AS min\n                    \n                        , json_extract(detail, '$.max') AS max\n                    \n                    FROM unioned_data\n            )\n        \n        , unpivoted_data AS (\n                SELECT\n                    column_name\n                    , dtype\n                    , key AS pivot_key\n                    , JSON(value) AS pivot_value ,\n                FROM\n            \n                flatten_data AS f\n                UNPIVOT (\n                    value FOR key IN (count, count_null, mean, percentile_25, percentile_50, percentile_75, unique_values, value_counts_top10, estimated_granularity, estimated_granularity_confidence, min, max)\n                )\n            \n\n        )\n        SELECT\n            column_name\n            , dtype\n            , count\n            , count_null\n            , ROUND((\n                CAST(count_null AS NUMERIC)\n                / (CAST(count AS NUMERIC)+CAST(count_null AS NUMERIC))\n            ),3)\n\n            AS percent_null\n            , * EXCLUDE(column_name, dtype\n                , count\n                , count_null\n            )\n        FROM\n        unpivoted_data\n        PIVOT(MIN(pivot_value) FOR pivot_key IN (\"count\", \"count_null\", \"mean\", \"percentile_25\", \"percentile_50\", \"percentile_75\", \"unique_values\", \"value_counts_top10\", \"estimated_granularity\", \"estimated_granularity_confidence\", \"min\", \"max\"))\n        ORDER BY dtype\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    1=1\n    -- filtered out the date column\n    AND\n    (\n        (\n        column_name NOT IN ('is_short_string', 'str_length', 'company_name', 'country')\n        )\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:17.373885Z", "completed_at": "2024-10-06T10:06:18.231194Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.233737Z", "completed_at": "2024-10-06T10:06:18.233737Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.876927375793457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_structure", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_generator_enriched_describe'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_str_length AS (\n                SELECT\n                    1\n                    \n                            , MIN(str_length) AS min\n                            , MAX(str_length) AS max\n                            \n                                , ROUND(AVG(str_length),4) AS avg\n                                \n                                , ROUND(APPROX_QUANTILE(str_length, 0.25),4) AS percentile_25\n                                , ROUND(APPROX_QUANTILE(str_length, 0.5),4) AS percentile_50\n                                , ROUND(APPROX_QUANTILE(str_length, 0.75),4) AS percentile_75\n                                \n                            \n                    \n\n\n                    , SUM(COUNT(str_length)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT str_length)) OVER () AS cnt_unique\n                    , COUNT_IF(str_length IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_numeric AS (\n            \n            \n            SELECT\n                'str_length' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'str_length'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'mean' , MIN(avg)\n                            , 'percentile_25' , MIN(percentile_25)\n                            , 'percentile_50' , MIN(percentile_50)\n                            , 'percentile_75' , MIN(percentile_75)\n                        \n                    \n                ) AS detail\n            FROM column_detail_str_length\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_day AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_day) AS min\n                            , MAX(date_day) AS max\n                            \n                                , MIN('Daily') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_day)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_day)) OVER () AS cnt_unique\n                    , COUNT_IF(date_day IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_day' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_day'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_day\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_is_short_string AS (\n                SELECT\n                    1\n                    \n                        , is_short_string\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(is_short_string)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT is_short_string)) OVER () AS cnt_unique\n                    , COUNT_IF(is_short_string IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_generator_enriched_describe\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_boolean AS (\n            \n            \n            SELECT\n                'is_short_string' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'is_short_string'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(is_short_string,false) AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_is_short_string\n            \n        \n\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    1=1\n    AND\n    (\n        (LOWER(meta_data_key) = 'nbr_of_columns' AND meta_data_value <> '5')\n        -- Rows = 54800\n        OR (LOWER(meta_data_key) = 'nbr_of_rows' AND meta_data_value <> '54800')\n        -- Date Columns = 1\n        OR (LOWER(meta_data_key) = 'nbr_of_date_columns' AND meta_data_value <> '1')\n        -- Time Columns = 1\n        OR (LOWER(meta_data_key) = 'nbr_of_time_columns' AND meta_data_value <> '0')\n        -- Boolean Columns = 1\n        OR (LOWER(meta_data_key) = 'nbr_of_boolean_columns' AND meta_data_value <> '1')\n        -- Text Columns = 1\n        OR (LOWER(meta_data_key) = 'nbr_of_text_columns' AND meta_data_value <> '2')\n        -- Numeric Columns = 1\n        OR (LOWER(meta_data_key) = 'nbr_of_numeric_columns' AND meta_data_value <> '1')\n    )", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.254861Z", "completed_at": "2024-10-06T10:06:18.282458Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.283980Z", "completed_at": "2024-10-06T10:06:18.283980Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0346529483795166, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.get_missing_dates_ex1", "compiled": true, "compiled_code": "/**\n * Retrieves the missing dates in the date_day column of the missing_day model at the Day level granularity.\n *\n * @param {string} missing_day - The name of the model.\n * @param {string} date_day - The name of the column containing the dates.\n * @param {array} [dimensions] - An optional array of dimensions across which the missing dates are computed.\n * @param {object} [filters] - An optional filter object.\n * @param {string} [expected_frequency] - The interval to use when generating the missing dates (e.g. 'DAY', 'MONTH', 'YEAR').\n * @returns {rows} Rows of missing dates.\n */\n\n\n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"get_missing_dates_ex1\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.289513Z", "completed_at": "2024-10-06T10:06:18.300083Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.302091Z", "completed_at": "2024-10-06T10:06:18.302091Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01458287239074707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.get_missing_dates_ex3", "compiled": true, "compiled_code": "/**\n * Retrieves the missing dates in the date_day column of the missing_day model at the Day level granularity.\n *\n * @param {string} missing_day - The name of the model.\n * @param {string} date_day - The name of the column containing the dates.\n * @param {array} [dimensions] - An optional array of dimensions across which the missing dates are computed.\n * @param {object} [filters] - An optional filter object.\n * @param {string} [expected_frequency] - The interval to use when generating the missing dates (e.g. 'DAY', 'MONTH', 'YEAR').\n * @returns {rows} Rows of missing dates.\n */\n\n\n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n      \n          \n            WHERE 1=1\n          \n\n          \n          \n            AND country IN ('DE', 'US')\n          \n      \n          \n\n          \n          \n            \n              AND  company_name = 'MSFT'\n            \n\n          \n      \n          \n\n          \n          \n            \n              AND  str_length >2\n            \n\n          \n      \n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"get_missing_dates_ex3\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.308133Z", "completed_at": "2024-10-06T10:06:18.320717Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.323712Z", "completed_at": "2024-10-06T10:06:18.323712Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.019098758697509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.get_missing_dates_ex4", "compiled": true, "compiled_code": "/**\n * Retrieves the missing dates in the date_day column of the missing_day model at the Day level granularity.\n *\n * @param {string} missing_day - The name of the model.\n * @param {string} date_day - The name of the column containing the dates.\n * @param {array} [dimensions] - An optional array of dimensions across which the missing dates are computed.\n * @param {object} [filters] - An optional filter object.\n * @param {string} [expected_frequency] - The interval to use when generating the missing dates (e.g. 'DAY', 'MONTH', 'YEAR').\n * @returns {rows} Rows of missing dates.\n */\n\n\n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n      \n          \n            WHERE 1=1\n          \n\n          \n          \n            AND country IN ('DE', 'US')\n          \n      \n          \n\n          \n          \n            AND company_name IN ('GOG', 'A')\n          \n      \n          \n\n          \n          \n            \n              AND  str_length =3\n            \n\n          \n      \n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"get_missing_dates_ex4\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.333877Z", "completed_at": "2024-10-06T10:06:18.344946Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.346455Z", "completed_at": "2024-10-06T10:06:18.346455Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.018094778060913086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.356527Z", "completed_at": "2024-10-06T10:06:18.366053Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.367558Z", "completed_at": "2024-10-06T10:06:18.367558Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.017101764678955078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_company", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 6", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.379627Z", "completed_at": "2024-10-06T10:06:18.392777Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.395304Z", "completed_at": "2024-10-06T10:06:18.395304Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.02019357681274414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_country", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 6", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.404230Z", "completed_at": "2024-10-06T10:06:18.415639Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.418066Z", "completed_at": "2024-10-06T10:06:18.418066Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01794266700744629, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_country_company", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 35", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.427313Z", "completed_at": "2024-10-06T10:06:18.443904Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.444913Z", "completed_at": "2024-10-06T10:06:18.444913Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.022127866744995117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_country_company_filtered_both", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n      \n          \n            WHERE 1=1\n          \n\n          \n          \n            \n              AND  country = 'DE'\n            \n\n          \n      \n          \n\n          \n          \n            \n              AND  company_name = 'A'\n            \n\n          \n      \n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 2", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.457025Z", "completed_at": "2024-10-06T10:06:18.467032Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.469227Z", "completed_at": "2024-10-06T10:06:18.469227Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.015788555145263672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_country_company_filtered_country", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n      \n          \n            WHERE 1=1\n          \n\n          \n          \n            \n              AND  country = 'DE'\n            \n\n          \n      \n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 10", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.478435Z", "completed_at": "2024-10-06T10:06:18.492504Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.495219Z", "completed_at": "2024-10-06T10:06:18.495219Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.021178483963012695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_day_by_country_company_numeric_filter", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_day\n          \n              , (country) AS country\n          \n              , (company_name) AS company_name\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_day\"\n    \n      \n          \n            WHERE 1=1\n          \n\n          \n          \n            AND country IN ('DE', 'US')\n          \n      \n          \n\n          \n          \n            AND company_name IN ('GOG', 'A')\n          \n      \n          \n\n          \n          \n            \n              AND  str_length =3\n            \n\n          \n      \n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_day,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n              (company_name) DESC,\n          \n          date_day DESC) AS next_date_day\n    FROM unique_dates\n  )\n  SELECT\n      date_day\n      \n          , (country) AS country\n      \n          , (company_name) AS company_name\n      \n      , next_date_day\n      , ABS(\n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_day::timestamp, date_day::timestamp ))\n     < -1\n\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\n-- Only rows corresponding to company A are picked up as the str_length is set to 3\nSELECT * FROM row_count_missing_values WHERE row_count <> 3", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.502052Z", "completed_at": "2024-10-06T10:06:18.511954Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.515515Z", "completed_at": "2024-10-06T10:06:18.515515Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.015462398529052734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.dbt_eda_tools.get_missing_dates_ex2", "compiled": true, "compiled_code": "/**\n * Retrieves the missing dates in the date_month column of the missing_month model at the Monthly level granularity.\n *\n * @param {string} missing_day - The name of the model.\n * @param {string} date_day - The name of the column containing the dates.\n * @param {array} [dimensions] - An optional array of dimensions across which the missing dates are computed.\n * @param {object} [filters] - An optional filter object.\n * @param {string} [expected_frequency] - The interval to use when generating the missing dates (e.g. 'DAY', 'MONTH', 'YEAR').\n * @returns {rows} Rows of missing dates.\n */\n\n\n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_month\n          \n              , (country) AS country\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_month\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_month,1) OVER (\n          ORDER BY\n          \n              (country) DESC,\n          \n          date_month DESC) AS next_date_month\n    FROM unique_dates\n  )\n  SELECT\n      date_month\n      \n          , (country) AS country\n      \n      , next_date_month\n      , ABS(\n        (date_diff('MONTH', next_date_month::timestamp, date_month::timestamp ))\n    ) AS missing_month\n  FROM dates_lagged\n  WHERE \n        (date_diff('MONTH', next_date_month::timestamp, date_month::timestamp ))\n     < -1\n", "relation_name": "\"dbt_db\".\"dbt_schema\".\"get_missing_dates_ex2\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.522054Z", "completed_at": "2024-10-06T10:06:18.535655Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.537664Z", "completed_at": "2024-10-06T10:06:18.537664Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01859569549560547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_month", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_month\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_month\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_month,1) OVER (\n          ORDER BY\n          \n          date_month DESC) AS next_date_month\n    FROM unique_dates\n  )\n  SELECT\n      date_month\n      \n      , next_date_month\n      , ABS(\n        (date_diff('MONTH', next_date_month::timestamp, date_month::timestamp ))\n    ) AS missing_month\n  FROM dates_lagged\n  WHERE \n        (date_diff('MONTH', next_date_month::timestamp, date_month::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_month) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.546680Z", "completed_at": "2024-10-06T10:06:18.556730Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.559727Z", "completed_at": "2024-10-06T10:06:18.559727Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.016057968139648438, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_month_by_days", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_month\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_month\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_month,1) OVER (\n          ORDER BY\n          \n          date_month DESC) AS next_date_month\n    FROM unique_dates\n  )\n  SELECT\n      date_month\n      \n      , next_date_month\n      , ABS(\n        (date_diff('DAY', next_date_month::timestamp, date_month::timestamp ))\n    ) AS missing_day\n  FROM dates_lagged\n  WHERE \n        (date_diff('DAY', next_date_month::timestamp, date_month::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_day) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 67", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.569769Z", "completed_at": "2024-10-06T10:06:18.584653Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.585654Z", "completed_at": "2024-10-06T10:06:18.585654Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01987457275390625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_year", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_year\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_year\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_year,1) OVER (\n          ORDER BY\n          \n          date_year DESC) AS next_date_year\n    FROM unique_dates\n  )\n  SELECT\n      date_year\n      \n      , next_date_year\n      , ABS(\n        (date_diff('YEAR', next_date_year::timestamp, date_year::timestamp ))\n    ) AS missing_year\n  FROM dates_lagged\n  WHERE \n        (date_diff('YEAR', next_date_year::timestamp, date_year::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_year) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.595712Z", "completed_at": "2024-10-06T10:06:18.604223Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:18.606237Z", "completed_at": "2024-10-06T10:06:18.606237Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.016579151153564453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_missing_year_by_month", "compiled": true, "compiled_code": "WITH\nmissing_values AS (\n    \n  WITH\n  unique_dates AS (\n    SELECT\n      DISTINCT\n          date_year\n          \n    FROM \"dbt_db\".\"dbt_schema\".\"missing_year\"\n    \n  )\n  , dates_lagged AS (\n    SELECT *\n    , LAG(date_year,1) OVER (\n          ORDER BY\n          \n          date_year DESC) AS next_date_year\n    FROM unique_dates\n  )\n  SELECT\n      date_year\n      \n      , next_date_year\n      , ABS(\n        (date_diff('MONTH', next_date_year::timestamp, date_year::timestamp ))\n    ) AS missing_month\n  FROM dates_lagged\n  WHERE \n        (date_diff('MONTH', next_date_year::timestamp, date_year::timestamp ))\n     < -1\n\n)\n, row_count_missing_values AS (\n    SELECT COUNT(missing_month) AS row_count\n    FROM missing_values\n)\nSELECT * FROM row_count_missing_values WHERE row_count <> 4", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-10-06T10:06:18.618321Z", "completed_at": "2024-10-06T10:06:19.418882Z"}, {"name": "execute", "started_at": "2024-10-06T10:06:19.419881Z", "completed_at": "2024-10-06T10:06:19.419881Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.8146355152130127, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.dbt_eda_tools.assert_data_describe_column_details_estimated_granularity_yearly", "compiled": true, "compiled_code": "WITH\ndescribe_dataframe AS (\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    WITH\n    \n    dummy AS (SELECT 1)\n    \n        , \n    \n    \n    meta_data AS (\n        -- Need to explicitly cast the type before transposing the data\n        SELECT\n        column_name\n        , data_type\n        , COUNT(*) OVER ():: STRING AS nbr_of_columns\n        , CASE\n                \n                    \n                        WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 'text'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 'date'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 'numeric'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 'boolean'\n                    \n                \n                    \n                        WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 'time'\n                    \n                \n                    \n                \n                    \n                \n                    \n                \n                    \n                \n        END AS data_type_input\n\n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('VARCHAR', 'CHAR', 'CHARACTER', 'STRING', 'TEXT') THEN 1 END) OVER ():: STRING AS nbr_of_text_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('DATE', 'DATETIME', 'TIMESTAMP', 'TIMESTAMP_LTZ', 'TIMESTAMP_NTZ', 'TIMESTAMP_TZ') THEN 1 END) OVER ():: STRING AS nbr_of_date_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('NUMBER', 'DECIMAL', 'NUMERIC', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'FLOAT', 'FLOAT4', 'FLOAT8', 'DOUBLE', 'DOUBLE PRECISION', 'REAL', 'INT64', 'TINYINT', 'BYETEINT', 'BIGDECIMAL', 'FLOAT64') THEN 1 END) OVER ():: STRING AS nbr_of_numeric_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('BOOLEAN', 'BOOL') THEN 1 END) OVER ():: STRING AS nbr_of_boolean_columns\n                \n            \n        \n            \n                \n                    , COUNT(CASE WHEN DATA_TYPE IN ('TIME', 'NEEDSTOBEARRAY') THEN 1 END) OVER ():: STRING AS nbr_of_time_columns\n                \n            \n        \n            \n        \n            \n        \n            \n        \n            \n        \n\n        FROM INFORMATION_SCHEMA.TABLES t\n        INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON\n                c.table_schema = t.table_schema AND c.table_name = t.table_name\n                WHERE t.table_name = 'data_aggregated_yearly_granularity'\n    )\n\n\n        \n        , \n\n    \n\n        meta_data_unique AS (\n            SELECT\n                    DISTINCT\n                    'dataset' AS identifier\n                    , '' AS detail\n                    , nbr_of_columns\n                    , nbr_of_text_columns\n                    , nbr_of_date_columns\n                    , nbr_of_numeric_columns\n                    , nbr_of_boolean_columns\n                    , nbr_of_time_columns\n                FROM meta_data\n        )\n        , dataset_info AS (\n            SELECT\n                    CASE LOWER(meta_data_key)\n                            WHEN 'nbr_of_columns' THEN 1\n                            WHEN 'nbr_of_text_columns' THEN 2\n                            WHEN 'nbr_of_date_columns' THEN 3\n                            WHEN 'nbr_of_numeric_columns' THEN 4\n                            WHEN 'nbr_of_boolean_columns' THEN 5\n                            WHEN 'nbr_of_time_columns' THEN 6\n                    END AS index_pos\n                    , meta_data_key\n                    , identifier\n                    , detail\n                    , CAST(meta_data_value AS STRING) AS meta_data_value\n                FROM meta_data_unique\n                UNPIVOT (meta_data_value FOR meta_data_key IN (nbr_of_columns, nbr_of_text_columns, nbr_of_date_columns, nbr_of_numeric_columns,nbr_of_boolean_columns,nbr_of_time_columns))\n        )\n\n    \n\n\n        \n        , \n\n    \n        rowcount_info AS (\n            SELECT\n                    0 AS index_pos\n                    , ('nbr_of_rows') AS meta_data_key\n                    , 'dataset' AS identifier\n                    , '' AS detail\n                    , CAST(COUNT(*) AS STRING) AS meta_data_value\n            FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_yearly_granularity\"\n            GROUP BY ALL\n        )\n    \n\n\n        \n        , \n\n    \n        column_info AS (\n            SELECT\n                20 + ROW_NUMBER() OVER (ORDER BY data_type) AS index_pos\n                , column_name AS meta_data_key\n                , 'column' AS identifier\n                , '' AS detail\n                , CAST(data_type AS STRING) AS meta_data_value\n            FROM meta_data\n        )\n    \n\n\n        \n        , \n    \n    assembled_result AS (\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            dataset_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            rowcount_info\n            UNION ALL\n        \n            SELECT\n                \n                     index_pos\n                \n                    , meta_data_key\n                \n                    , meta_data_value\n                \n                    , identifier\n                \n                    , detail\n                \n            FROM\n            column_info\n            \n        \n    )\n\n\n    \n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_numeric AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n\n\n            column_detail_country AS (\n                SELECT\n                    1\n                    \n                        , country\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(country)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT country)) OVER () AS cnt_unique\n                    , COUNT_IF(country IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_yearly_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) ,\n        \n\n            \n\n\n            column_detail_company_name AS (\n                SELECT\n                    1\n                    \n                        , company_name\n                        , COUNT(*) AS cnt\n                    \n\n\n                    , SUM(COUNT(company_name)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT company_name)) OVER () AS cnt_unique\n                    , COUNT_IF(company_name IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_yearly_granularity\"\n\n                GROUP BY ALL\n\n                \n                    ORDER by cnt_null DESC, cnt DESC\n                    LIMIT 10\n                \n\n            ) \n        \n\n        \n        , column_detail_info_text AS (\n            \n            \n            SELECT\n                'country' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'country'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(country,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_country\n            UNION ALL\n        \n            \n            SELECT\n                'company_name' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'company_name'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        \n                            , 'unique_values' , MIN(cnt_unique)\n                        \n                        , 'value_counts_top10',\n                            ARRAY_AGG\n                                (JSON_OBJECT(\n                                    CAST(COALESCE(company_name,'NULL') AS STRING)\n                                , cnt)\n                                )\n                    \n                ) AS detail\n            FROM column_detail_company_name\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        \n        \n\n            \n                \n            \n\n\n            column_detail_date_mixed_granularity AS (\n                SELECT\n                    1\n                    \n                            , MIN(date_mixed_granularity) AS min\n                            , MAX(date_mixed_granularity) AS max\n                            \n                                , MIN('Yearly') AS estimated_granularity\n                                , MIN(1.0) AS estimated_granularity_confidence\n                            \n                    \n\n\n                    , SUM(COUNT(date_mixed_granularity)) OVER () AS cnt_total\n                    , SUM(COUNT(DISTINCT date_mixed_granularity)) OVER () AS cnt_unique\n                    , COUNT_IF(date_mixed_granularity IS NULL) AS cnt_null\n\n                FROM \"dbt_db\".\"dbt_schema\".\"data_aggregated_yearly_granularity\"\n\n                GROUP BY ALL\n\n                \n\n            ) \n        \n\n        \n        , column_detail_info_date AS (\n            \n            \n            SELECT\n                'date_mixed_granularity' AS column_name\n                , JSON_OBJECT(\n                    'column_name', 'date_mixed_granularity'\n                    , 'count' , MIN(cnt_total)\n                    , 'count_null' , MAX(cnt_null) -- needs to be max not min otherwise always zero\n                    \n                        , 'min' , MIN(min)\n                        , 'max' , MIN(max)\n                        \n                            , 'estimated_granularity' , MIN(estimated_granularity)\n                            , 'estimated_granularity_confidence' , MIN(estimated_granularity_confidence)\n                        \n                    \n                ) AS detail\n            FROM column_detail_date_mixed_granularity\n            \n        \n\n        )\n    \n\n\n    \n        , \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n        column_detail_info_boolean AS (\n            SELECT\n                '' AS column_name\n                , TO_JSON(NULL) AS detail\n        )\n    \n\n\n    \n\n    \n        \n\n\n\n\n\n    SELECT\n        assembed_result.meta_data_key\n        , assembed_result.meta_data_value\n        , assembed_result.identifier\n        , COALESCE(text_detail.detail, numeric_detail.detail,date_detail.detail, boolean_detail.detail) AS detail\n    FROM assembled_result AS assembed_result\n    LEFT JOIN column_detail_info_text AS text_detail\n    ON assembed_result.meta_data_key = text_detail.column_name\n    LEFT JOIN column_detail_info_numeric AS numeric_detail\n    ON assembed_result.meta_data_key = numeric_detail.column_name\n    LEFT JOIN column_detail_info_date AS date_detail\n    ON assembed_result.meta_data_key = date_detail.column_name\n    LEFT JOIN column_detail_info_boolean AS boolean_detail\n    ON assembed_result.meta_data_key = boolean_detail.column_name\n\n    ORDER BY index_pos ASC\n\n\n    \n\n\n)\nSELECT * FROM describe_dataframe\nWHERE\n    identifier = 'column'\n    AND\n    (\n        (\n            LOWER(meta_data_value) = 'date'\n\n            AND (\n\n                detail IS NULL\n\n                OR (\n                    meta_data_key = 'DATE_MIXED_GRANULARITY' AND (\n                    CAST(detail->>'column_name' AS STRING) <> 'DATE_MIXED_GRANULARITY'\n                    OR CAST(detail->>'estimated_granularity' AS STRING)  <> '\"Yearly\"'\n                    OR CAST(detail->>'estimated_granularity_confidence' AS INTEGER) <> 1\n                    OR CAST(detail->>'count' AS INTEGER) <> 4\n                    OR CAST(detail->>'count_null' AS INTEGER) <> 0\n                    OR CAST(detail->>'min' AS DATE) <> CAST('2019-01-01' AS DATE)\n                    OR CAST(detail->>'max' AS DATE)<> CAST('2022-01-01' AS DATE)\n                    )\n                )\n            )\n        )\n    )", "relation_name": null}], "elapsed_time": 12.05759048461914, "args": {"cache_selected_only": false, "which": "generate", "log_path": "C:\\Users\\shank\\Google Drive\\Jupyter Data\\Consulting\\External\\Kering\\Sourcev1\\Coding\\dbt_eda_tools\\logs", "log_format_file": "debug", "favor_state": false, "use_colors_file": true, "compile": true, "source_freshness_run_project_hooks": false, "populate_cache": true, "warn_error_options": {"include": [], "exclude": []}, "strict_mode": false, "partial_parse_file_diff": true, "require_resource_names_without_spaces": false, "use_colors": true, "vars": {}, "log_format": "default", "project_dir": "C:\\Users\\shank\\Google Drive\\Jupyter Data\\Consulting\\External\\Kering\\Sourcev1\\Coding\\dbt_eda_tools", "require_explicit_package_overrides_for_builtin_materializations": true, "show_resource_report": false, "static": false, "invocation_command": "dbt docs generate", "printer_width": 80, "log_level": "info", "profiles_dir": "C:\\Users\\shank\\.dbt", "exclude": [], "empty_catalog": false, "indirect_selection": "eager", "quiet": false, "select": [], "version_check": true, "partial_parse": true, "enable_legacy_logger": false, "log_level_file": "debug", "log_file_max_bytes": 10485760, "write_json": true, "static_parser": true, "send_anonymous_usage_stats": true, "defer": false, "macro_debugging": false, "introspect": true, "print": true}}